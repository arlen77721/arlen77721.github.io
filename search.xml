<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>对map集合的操作</title>
    <url>/2024/03/26/java/stream%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h5 id="1、对map集合的操作"><a href="#1、对map集合的操作" class="headerlink" title="1、对map集合的操作"></a>1、对map集合的操作</h5><ul>
<li><p>map集合value总和   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> datas.entrySet().stream().filter(entry -&gt; !entry.getKey().equals(<span class="string">&quot;1&quot;</span>) &amp;&amp; !entry.getKey().equals(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">                      &amp;&amp; !entry.getKey().equals(<span class="string">&quot;6&quot;</span>) &amp;&amp; !entry.getKey().equals(<span class="string">&quot;7&quot;</span>) &amp;&amp; !entry.getKey().equals(<span class="string">&quot;8&quot;</span>)</span><br><span class="line">                      &amp;&amp; !entry.getKey().equals(<span class="string">&quot;10&quot;</span>))</span><br><span class="line">                      .mapToLong(entry -&gt; Long.parseLong(entry.getValue())).sum();</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并两个map,key相同的value进行加和</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map1.forEach((key, value) -&gt; map2.merge(key, value, Integer::sum));<span class="comment">//map1合并到map2,map类型&lt;String,Integer&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2、对list集合的操作"><a href="#2、对list集合的操作" class="headerlink" title="2、对list集合的操作"></a>2、对list集合的操作</h5><ul>
<li>根据时间对list集合的对象进行升序排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;ThirdCloudAlarmDto&gt; dtoList = collect.get(key).stream()</span><br><span class="line">                   .sorted(Comparator.comparing(ThirdCloudAlarmDto::getOccurTime)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<ul>
<li>stream流根据时间筛选所需数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;CameraAlarmDto&gt; collect = cameraAlarms.stream().</span><br><span class="line">                        filter(e -&gt; (e.getTimeLast().after(startDate) &amp;&amp;</span><br><span class="line">                                e.getTimeLast().before(endDate))).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<ul>
<li>对list集合根据某一个元素进行过滤，并选取过滤后的集合对象中的某些属性组合成新的集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">groups.forEach(group -&gt; &#123;</span><br><span class="line">           List&lt;DceEquipGroupInfoVo&gt; dceEquipGroupInfoVos = dceEquipInfoDtos.stream().</span><br><span class="line">                   filter((DceEquipGroupInfoDto d) -&gt; group.getNodeName().equals(d.getNodeName())).</span><br><span class="line">                   map(item -&gt; &#123;</span><br><span class="line">                       <span class="type">DceEquipGroupInfoVo</span> <span class="variable">equipGroupInfoVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DceEquipGroupInfoVo</span>();</span><br><span class="line">                       equipGroupInfoVo.setEquipKey(item.getEquipKey()).setEquipName(item.getEquipName());</span><br><span class="line">                       <span class="keyword">return</span> equipGroupInfoVo;</span><br><span class="line">                   &#125;).distinct().collect(Collectors.toList());</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对List集合使用分页查询</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thirdCloudHostDtos = thirdCloudHostDtos.stream().skip((pageNum - <span class="number">1</span>) * pageSize)</span><br><span class="line">                    .limit(pageSize).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<ul>
<li>对list集合中对象中属性为字符串数字比较倒叙排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;MetricVO&gt; listTop5 = list.stream().sorted(Comparator.comparing(MetricVO::getValue,</span><br><span class="line">               Comparator.comparingInt(Integer::parseInt)).reversed()).limit(<span class="number">5</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<ul>
<li>使用stream流进行模糊查询</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">keyWordsList = dtoList.stream().filter(e -&gt; Boolean.FALSE ? e.getServerIp().equals(keyWords)</span><br><span class="line">                     || e.getServerPort().equals(keyWords) || e.getClientIp().equals(keyWords)</span><br><span class="line">                     || e.getClientPort().equals(keyWords) || e.getAppProgram().equals(keyWords)</span><br><span class="line">                     || e.getProtocol().equals(keyWords) :</span><br><span class="line">                     (e.getServerIp().contains(keyWords)) || e.getServerPort().contains(keyWords) || e.getClientIp().contains(keyWords)</span><br><span class="line">                             || e.getClientPort().contains(keyWords) || e.getAppProgram().contains(keyWords)</span><br><span class="line">                             || e.getProtocol().contains(keyWords)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<ul>
<li>取多个list集合的交集</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dealedList = keyWordsList.stream().filter(appList::contains).filter(protocolList::contains).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<ul>
<li>根据对象某一字段组成类型集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; appTypes = dtoList.stream().filter(item -&gt;item.getAppProgram() != <span class="literal">null</span>)</span><br><span class="line">                       .map(HistoricalFlowDto::getAppProgram).distinct().collect(Collectors.toList());  </span><br></pre></td></tr></table></figure>
<ul>
<li>求list属性中某一属性的和</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">totalOrders</span> <span class="operator">=</span> usedStatisticsVoList.stream().mapToInt(ServiceUsedStatisticsVo :: getWorkOrderNum).sum();  <span class="comment">//list中存储的是对象</span></span><br><span class="line"> </span><br><span class="line"> <span class="type">Long</span> <span class="variable">totalOrders</span> <span class="operator">=</span> mapList.stream().mapToLong((s) -&gt; Long.valueOf(String.valueOf(s.get(<span class="string">&quot;num&quot;</span>)))).sum();  <span class="comment">//list中存储的是map集合</span></span><br></pre></td></tr></table></figure>

<ul>
<li>根据list中对象的某一属性组合成新的集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; instanceIds = instances.stream().map(ThirdCloudInstance::getInstanceId).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<ul>
<li>按照list对象中的某一属性进行分组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;MonitorBusyDegreeResult&gt;&gt; collect = list.stream()</span><br><span class="line">        .collect(Collectors.groupingBy(MonitorBusyDegreeResult::getDataDesc));</span><br></pre></td></tr></table></figure>

<ul>
<li>list中存储对象，根据对象某一属性排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt; MetricVO&gt; metricVosBusy  = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">businessSystems.stream().sorted(Comparator.comparing(MonitorBusyDegreeResult::getBusyDegree, Comparator.reverseOrder())).collect(Collectors.toList())</span><br><span class="line">        .forEach(e -&gt; &#123;</span><br><span class="line">            metricVosBusy.add(<span class="keyword">new</span> <span class="title class_">MetricVO</span>().setKey(e.getDataDesc()).setValue(String.valueOf(e.getBusyDegree())));</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>list中存储map,按map中的某一key对应的value进行排序，取排行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">     <span class="comment">//正序//  </span></span><br><span class="line">     List&lt;Map&lt;String, Object&gt;&gt; listTop9 = list.stream().sorted(Comparator.comparing(e -&gt; org.apache.commons.collections.MapUtils.getLong(e, <span class="string">&quot;count&quot;</span>))).limit(<span class="number">9</span>).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//逆序</span></span><br><span class="line">     List&lt;Map&lt;String, Object&gt;&gt; listTop9 = list.stream().sorted((c1, c2) -&gt; org.apache.commons.collections.MapUtils.getDouble(c2, <span class="string">&quot;count&quot;</span>)        .compareTo(org.apache.commons.collections.MapUtils.getDouble(c1, <span class="string">&quot;count&quot;</span>))).limit(<span class="number">9</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<pre><code>注意事项：

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、stream流中不要对变量进行操作，如果你需要对变量进行操作，则最好不要用stream流，避免在stream流中对变量进行操作</span><br><span class="line">2、遍历的时候需要通过条件判断跳出本次循环的时候可以使用return等同于for循环中的continue，如果有需要直接结束循环的操作就不建议使用stream流进行遍历了</span><br><span class="line">3、使用parallelStream并行流的时候，要注意线程安全问题，建议能不用并行流的时候就不要用并行流。</span><br></pre></td></tr></table></figure>
</code></pre>
]]></content>
      <categories>
        <category>Java对map集合的操作</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>创建线程池</title>
    <url>/2024/03/25/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1、创建线程池"><a href="#1、创建线程池" class="headerlink" title="1、创建线程池"></a>1、创建线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadUtil</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(value = &quot;executorService&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ExecutorService <span class="title function_">getExecutorService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">3600</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、使用线程池"><a href="#2、使用线程池" class="headerlink" title="2、使用线程池"></a>2、使用线程池</h3><ul>
<li>不需要获取结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryECSMetricInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//发送到kafka的消息集合,因为使用了多线程，并且在多线程中往该集合进行添加操作，所以需要线程安全的</span></span><br><span class="line">    List&lt;Message&gt; messages = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//获取上次查询时间</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> Long.valueOf(queryTimeRecordMapper.selectTimeByBelongId(<span class="number">3</span>)) * <span class="number">1000</span>;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//查询出所有的运行中的实例</span></span><br><span class="line">        List&lt;CloudInstanceAssetDto&gt; cloudInstances = cloudInstanceAssetMapper.queryAllRunningInstance(<span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(cloudInstances)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义计数器</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(cloudInstances.size());</span><br><span class="line">        <span class="comment">//遍历查询</span></span><br><span class="line">        <span class="keyword">for</span> (CloudInstanceAssetDto instance : cloudInstances) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取内网流出带宽，并将结果封装到消息集合中</span></span><br><span class="line">                    dealMetricDataToMessage(ALiYunConstant.ECS_INTRANET_OUT_RATE, ALiYunConstant.INTRANET_OUT_RATE_NAME, ALiYunConstant.LW_INTRANET_OUT_RATE_CODE,</span><br><span class="line">                            startTime, endTime, instance, messages);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;获取ECS的指标数据-多线程处理任务异常！&quot;</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待任务执行完毕</span></span><br><span class="line">        latch.await();</span><br><span class="line">      <span class="comment">//  service.shutdown();</span></span><br><span class="line">        <span class="comment">//将最终的消息集合发送到kafka</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(messages)) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; tagMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            tagMap.put(<span class="string">&quot;group&quot;</span>, <span class="string">&quot;ecs-metric&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; messages.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotBlank(messages.get(i).getValue())</span><br><span class="line">                        &amp;&amp; <span class="string">&quot;noSuchInstance&quot;</span>.equals(messages.get(i).getValue())) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messages.get(i);</span><br><span class="line">                OpenTSDBUtils.putData(message.getCode() + <span class="string">&quot;-&quot;</span> + message.getHost(), Long.parseLong(message.getTime()),</span><br><span class="line">                        Double.valueOf(message.getValue()), tagMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        log.error(<span class="string">&quot;获取ECS的指标数据失败&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新记录上次查询时间</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="type">QueryTimeRecord</span> <span class="variable">queryTimeRecord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryTimeRecord</span>();</span><br><span class="line">        queryTimeRecord.setBelongId(<span class="number">3</span>).setLastQueryTime(String.valueOf((endTime - <span class="number">1000</span> * <span class="number">60</span> * <span class="number">1</span>) / <span class="number">1000</span>)); <span class="comment">//开始时间往前推1分钟</span></span><br><span class="line">        queryTimeRecordMapper.updateByBelongId(queryTimeRecord);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要获取线程执行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryECSMetricInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//发送到kafka的消息集合,因为使用了多线程，并且在多线程中往该集合进行添加操作，所以需要线程安全的</span></span><br><span class="line">    List&lt;Future&lt;List&lt;Message&gt;&gt;&gt; futures  =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Message&gt; messages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//获取上次查询时间</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> Long.valueOf(queryTimeRecordMapper.selectTimeByBelongId(<span class="number">3</span>)) * <span class="number">1000</span>;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//查询出所有的运行中的实例</span></span><br><span class="line">        List&lt;CloudInstanceAssetDto&gt; cloudInstances = cloudInstanceAssetMapper.queryAllRunningInstance(<span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(cloudInstances)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义计数器</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(cloudInstances.size());</span><br><span class="line">        <span class="comment">//遍历查询</span></span><br><span class="line">        <span class="keyword">for</span> (CloudInstanceAssetDto instance : cloudInstances) &#123;</span><br><span class="line">           Future&lt;Message&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取内网流出带宽，并将结果封装到消息集合中</span></span><br><span class="line">                    List&lt;Message&gt; curMessages = dealMetricDataToMessage(ALiYunConstant.ECS_INTRANET_OUT_RATE, ALiYunConstant.INTRANET_OUT_RATE_NAME, ALiYunConstant.LW_INTRANET_OUT_RATE_CODE,</span><br><span class="line">                            startTime, endTime, instance);</span><br><span class="line">                    <span class="keyword">return</span> curMessages;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;获取ECS的指标数据-多线程处理任务异常！&quot;</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;);</span><br><span class="line">          </span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待任务执行完毕</span></span><br><span class="line">        latch.await();</span><br><span class="line">      <span class="comment">//  service.shutdown();</span></span><br><span class="line">        <span class="comment">//处理线程执行结果</span></span><br><span class="line">        <span class="keyword">for</span>(Future&lt;List&lt;Message&gt;&gt; future:futures)&#123;</span><br><span class="line">            messages.add(future.get());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将最终的消息集合发送到kafka</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(messages)) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; tagMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            tagMap.put(<span class="string">&quot;group&quot;</span>, <span class="string">&quot;ecs-metric&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; messages.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotBlank(messages.get(i).getValue())</span><br><span class="line">                        &amp;&amp; <span class="string">&quot;noSuchInstance&quot;</span>.equals(messages.get(i).getValue())) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messages.get(i);</span><br><span class="line">                OpenTSDBUtils.putData(message.getCode() + <span class="string">&quot;-&quot;</span> + message.getHost(), Long.parseLong(message.getTime()),</span><br><span class="line">                        Double.valueOf(message.getValue()), tagMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        log.error(<span class="string">&quot;获取ECS的指标数据失败&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新记录上次查询时间</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="type">QueryTimeRecord</span> <span class="variable">queryTimeRecord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryTimeRecord</span>();</span><br><span class="line">        queryTimeRecord.setBelongId(<span class="number">3</span>).setLastQueryTime(String.valueOf((endTime - <span class="number">1000</span> * <span class="number">60</span> * <span class="number">1</span>) / <span class="number">1000</span>)); <span class="comment">//开始时间往前推1分钟</span></span><br><span class="line">        queryTimeRecordMapper.updateByBelongId(queryTimeRecord);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java创建线程池</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JSX简介</title>
    <url>/2024/03/24/react/JSX%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="JSX简介"><a href="#JSX简介" class="headerlink" title="JSX简介"></a>JSX简介</h1><h2 id="什么是JSX？"><a href="#什么是JSX？" class="headerlink" title="什么是JSX？"></a>什么是JSX？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<p>以类似模板语法的方式描述UI的一种语法。它是JS的<strong>语法糖</strong>，<strong>本质上也是JS</strong>。可以在其中使用<strong>变量或表达式、函数等</strong>。</p>
<h2 id="为什么使用JSX？"><a href="#为什么使用JSX？" class="headerlink" title="为什么使用JSX？"></a>为什么使用JSX？</h2><p>将<em>标记与逻辑</em> 共同存放在称之为“组件”的松散耦合单元之中，来实现<a href="https://en.wikipedia.org/wiki/Separation_of_concerns"><em>关注点分离</em></a>。</p>
<p>React不强制使用JSX，但在 JavaScript 代码中将 JSX 和 UI 放在一起时，会在<strong>视觉上有辅助作用</strong>。</p>
<h2 id="在-JSX-中嵌入表达式"><a href="#在-JSX-中嵌入表达式" class="headerlink" title="在 JSX 中嵌入表达式"></a>在 JSX 中嵌入表达式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;2+2&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<p>在 JSX 语法中，你可以在大括号内放置任何有效的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions">JavaScript 表达式</a>。</p>
<h2 id="JSX-也是一个表达式"><a href="#JSX-也是一个表达式" class="headerlink" title="JSX 也是一个表达式"></a>JSX 也是一个表达式</h2><p>在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后<strong>得到 JavaScript 对象</strong></p>
<blockquote>
<p>可以把JSX当初一个对象来对待，可以使用它赋值给变量、当参数输入函数、返回JSX等。</p>
</blockquote>
<h2 id="JSX-特定属性"><a href="#JSX-特定属性" class="headerlink" title="JSX 特定属性"></a>JSX 特定属性</h2><p>通过使用引号，来将属性值指定为字符串字面量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">tabIndex</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JSX中的属性名使用camelCase(小驼峰)命名。如上面例子中的<code>tabIndex</code></p>
</blockquote>
<p>使用大括号，来在属性值中插入一个 JavaScript 表达式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="使用-JSX-指定子元素"><a href="#使用-JSX-指定子元素" class="headerlink" title="使用 JSX 指定子元素"></a>使用 JSX 指定子元素</h2><p>JSX 标签里能够包含很多子元素:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Good to see you here.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h2 id="JSX-防止注入攻击"><a href="#JSX-防止注入攻击" class="headerlink" title="JSX 防止注入攻击"></a>JSX 防止注入攻击</h2><p>React DOM 在渲染所有输入内容之前，默认会进行<a href="https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html">转义</a>。它可以确保在你的应用中，<strong>永远不会注入那些并非自己明确编写的内容</strong>。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS（cross-site-scripting, 跨站脚本）</a>攻击。</p>
<h2 id="JSX-表示对象"><a href="#JSX-表示对象" class="headerlink" title="JSX 表示对象"></a>JSX 表示对象</h2><p>Babel 会把 JSX 转译成一个名为 <code>React.createElement()</code> 函数调用。</p>
<p>以下两种示例代码完全等效：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;greeting&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Hello, world!</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">  <span class="string">&#x27;h1&#x27;</span>, <span class="comment">// 标签名</span></span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">&#x27;greeting&#x27;</span>&#125;, <span class="comment">// 属性对象</span></span><br><span class="line">  <span class="string">&#x27;Hello, world!&#x27;</span> <span class="comment">// 内容</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>《React》笔记</category>
        <category>核心概念</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React哲学</title>
    <url>/2024/03/26/react/React%E5%93%B2%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="React哲学（编写一个复杂组件的原则）"><a href="#React哲学（编写一个复杂组件的原则）" class="headerlink" title="React哲学（编写一个复杂组件的原则）"></a>React哲学（编写一个复杂组件的原则）</h1><p>React 最棒的部分之一是引导我们思考如何构建一个应用。在这篇文档中，我们将会通过 React 构建一个可搜索的产品数据表格来更深刻地领会 React 哲学。</p>
<h2 id="从设计稿开始"><a href="#从设计稿开始" class="headerlink" title="从设计稿开始"></a>从设计稿开始</h2><p><img src="https://zh-hans.reactjs.org/static/1071fbcc9eed01fddc115b41e193ec11/d4770/thinking-in-react-mock.png" alt="Mockup"></p>
<h3 id="第一步：将设计好的-UI-划分为组件层级"><a href="#第一步：将设计好的-UI-划分为组件层级" class="headerlink" title="第一步：将设计好的 UI 划分为组件层级"></a>第一步：将设计好的 UI 划分为组件层级</h3><p><strong>首先，你需要在设计稿上用方框圈出每一个组件（包括它们的子组件）</strong></p>
<p><img src="https://zh-hans.reactjs.org/static/eb8bda25806a89ebdc838813bdfa3601/6b2ea/thinking-in-react-components.png" alt="Component diagram"></p>
<p>你会看到我们的应用中包含五个组件。我们已经将每个组件展示的数据标注为了斜体。</p>
<ol>
<li><strong><code>FilterableProductTable</code> (橙色):</strong> 是整个示例应用的整体</li>
<li><strong><code>SearchBar</code> (蓝色):</strong> 接受所有的<em>用户输入</em></li>
<li><strong><code>ProductTable</code> (绿色):</strong> 展示<em>数据内容</em>并根据<em>用户输入</em>筛选结果</li>
<li><strong><code>ProductCategoryRow</code> (天蓝色):</strong> 为每一个<em>产品类别</em>展示标题</li>
<li><strong><code>ProductRow</code> (红色):</strong> 每一行展示一个<em>产品</em></li>
</ol>
<p>你可能注意到，<code>ProductTable</code> 的表头（包含 “Name” 和 “Price” 的那一部分）并未单独成为一个组件。这仅仅是一种偏好选择，如何处理这一问题也一直存在争论。（简单的可以不用单独分一个组件，复杂的作为一个独立的组件就有必要了）</p>
<p>组件层级：</p>
<ul>
<li><code>FilterableProductTable</code><ul>
<li><code>SearchBar</code></li>
<li><code>ProductTable</code><ul>
<li><code>ProductCategoryRow</code></li>
<li><code>ProductRow</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第二步：用-React-创建一个静态版本"><a href="#第二步：用-React-创建一个静态版本" class="headerlink" title="第二步：用 React 创建一个静态版本"></a>第二步：用 React 创建一个静态版本</h3><p>先用已有的数据模型渲染一个不包含交互功能的 UI。最好将渲染 UI 和添加交互这两个过程分开。</p>
<p>这是因为，编写一个应用的静态版本时，往往要编写大量代码，而不需要考虑太多交互细节；添加交互功能时则要考虑大量细节，而不需要编写太多代码。</p>
<p>在构建应用的静态版本时，我们需要创建一些会重用其他组件的组件，然后通过 <em>props</em> 传入所需的数据。<em>props</em> 是父组件向子组件传递数据的方式。即使你已经熟悉了 <em>state</em> 的概念，也<strong>完全不应该使用 state</strong> 构建静态版本。state 代表了随时间会产生变化的数据。</p>
<p>你可以自上而下或者自下而上构建应用：自上而下意味着首先编写层级较高的组件（比如 <code>FilterableProductTable</code>），自下而上意味着从最基本的组件开始编写（比如 <code>ProductRow</code>）。<strong>当你的应用比较简单时，使用自上而下的方式更方便；对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式。</strong></p>
<p>React <strong>单向数据流</strong>（也叫<em>单向绑定</em>）的思想使得组件模块化，易于快速开发。</p>
<p>在 React 中，<strong>有两类“模型”数据：props 和 state</strong>。清楚地理解两者的区别是十分重要的</p>
<h3 id="第三步：确定-UI-state-的最小（且完整）表示"><a href="#第三步：确定-UI-state-的最小（且完整）表示" class="headerlink" title="第三步：确定 UI state 的最小（且完整）表示"></a>第三步：确定 UI state 的最小（且完整）表示</h3><p><strong>只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生。</strong></p>
<p><strong>可以由state计算产生的数据就没必要另外保存一个state！</strong></p>
<p>对于使用props还是state，通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：</p>
<ol>
<li>该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。</li>
<li>该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。</li>
<li>你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。</li>
</ol>
<blockquote>
<p><strong>非state的数据</strong>： </p>
<ol>
<li>由父组件传来的</li>
<li>不会随时间推移而改变的</li>
<li>能根据其他stete或props计算而来的</li>
</ol>
</blockquote>
<h3 id="第四步：确定-state-放置的位置"><a href="#第四步：确定-state-放置的位置" class="headerlink" title="第四步：确定 state 放置的位置"></a>第四步：确定 state 放置的位置</h3><p>我们需要确定哪个组件能够改变这些 state，或者说<em>拥有</em>这些 state。</p>
<p><strong>注意：React 中的数据流是单向的，并顺着组件层级从上往下传递。</strong></p>
<p>对于应用中的每一个 state：</p>
<ul>
<li>找到根据这个 state 进行渲染的所有组件。</li>
<li>找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。</li>
<li>该共同所有者组件或者比它层级更高的组件应该拥有该 state。</li>
<li>如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置</li>
</ul>
<h3 id="第五步：添加反向数据流"><a href="#第五步：添加反向数据流" class="headerlink" title="第五步：添加反向数据流"></a>第五步：添加反向数据流</h3><p>让<strong>数据反向传递：处于较低层级的表单组件更新较高层级组件的state</strong></p>
<p>实现方式：</p>
<ol>
<li><p>父组件有一个能够修改state改变的回调函数，并传递给子组件</p>
</li>
<li><p>子组件的input修改值，使用<code>onChange</code>事件监听，并执行父组件传入的回调函数。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>《React》笔记</category>
        <category>核心概念</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>State&amp;生命周期</title>
    <url>//pages/1e3ca2/</url>
    <content><![CDATA[<h1 id="State-生命周期"><a href="#State-生命周期" class="headerlink" title="State &amp; 生命周期"></a>State &amp; 生命周期</h1><p>State 与 props 类似，但是 <strong>state 是私有的，并且完全受控于当前组件.</strong></p>
<blockquote>
<p>State类似于vue中的data选项</p>
</blockquote>
<h2 id="将函数组件转换成-class-组件"><a href="#将函数组件转换成-class-组件" class="headerlink" title="将函数组件转换成 class 组件"></a>将函数组件转换成 class 组件</h2><blockquote>
<p>在没有useState钩子函数之前，是通过class组件管理State ？</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;this.props.date.toLocalTimeString()&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次组件更新时 <code>render</code> 方法都会被调用，但只要在相同的 DOM 节点中渲染 <code>&lt;Clock /&gt;</code> ，就<strong>仅有一个 <code>Clock</code> 组件的 class 实例被创建使用</strong>。这就使得我们可以使用如 state 或生命周期方法等很多其他特性。</p>
<blockquote>
<p>单例模式？</p>
</blockquote>
<h2 id="向-class-组件中添加局部的-state"><a href="#向-class-组件中添加局部的-state" class="headerlink" title="向 class 组件中添加局部的 state"></a>向 class 组件中添加局部的 state</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// 第二步：添加构造函数，并给 this.state 赋初始值</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props) <span class="comment">// 通过super将props传递到父类构造函数中</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 第一步：render 方法内，将 this.props 替换成 this.state</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;this.state.date.toLocalTimeString()&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h2 id="将生命周期方法添加到-Class-中"><a href="#将生命周期方法添加到-Class-中" class="headerlink" title="将生命周期方法添加到 Class 中"></a>将生命周期方法添加到 Class 中</h2><p>在具有许多组件的应用程序中，当组件被销毁时释放所占用的资源是非常重要的。</p>
<p>当 <code>Clock</code> 组件第一次被渲染到 DOM 中的时候，就为其<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval">设置一个计时器</a>。这在 React 中被称为“<strong>挂载（mount）</strong>”。</p>
<p>同时，当 DOM 中 <code>Clock</code> 组件被删除的时候，应该<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval">清除计时器</a>。这在 React 中被称为“<strong>卸载（unmount）</strong>”。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 挂载 - 挂载完成后执行</span></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 组件挂载后开启定时器</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timerID</span> = <span class="title function_">serInterval</span>( <span class="comment">// 可以向this添加任意属性字段</span></span><br><span class="line">    	<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">tick</span>(), <span class="number">1000</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 卸载</span></span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 组件卸载后清除定时器，释放内存</span></span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timerID</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;this.state.date.toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h2 id="正确地使用-State"><a href="#正确地使用-State" class="headerlink" title="正确地使用 State"></a>正确地使用 State</h2><p>关于 <code>setState()</code> 你应该了解三件事：</p>
<h3 id="不要直接修改-State"><a href="#不要直接修改-State" class="headerlink" title="不要直接修改 State"></a>不要直接修改 State</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Wrong 不要直接修改state</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">comment</span> = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Correct 应使用 setState() 方法</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">comment</span>: <span class="string">&#x27;Hello&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>构造函数是唯一可以给 <code>this.state</code> 直接赋值的地方</strong></p>
<blockquote>
<p>setState是React内部方法，使state更新具有响应式？</p>
</blockquote>
<h3 id="State-的更新可能是异步的"><a href="#State-的更新可能是异步的" class="headerlink" title="State 的更新可能是异步的"></a>State 的更新可能是异步的</h3><p>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用。</p>
<p>因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以你<strong>不要依赖他们的值来更新下一个状态</strong>。</p>
<p>要<strong>解决这个问题，可以让 <code>setState()</code> 接收一个函数而不是一个对象</strong>。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">counter</span>: state.<span class="property">counter</span> + props.<span class="property">increment</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>



<h3 id="State-的更新会被合并"><a href="#State-的更新会被合并" class="headerlink" title="State 的更新会被合并"></a>State 的更新会被合并</h3><p>当你调用 <code>setState()</code> 的时候，React 会把你提供的对象合并到当前的 state</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">posts</span>: [],</span><br><span class="line">      <span class="attr">comments</span>: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别调用setState单独更新state下的属性</span></span><br><span class="line"> <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fetchPosts</span>().<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">posts</span>: response.<span class="property">posts</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">fetchComments</span>().<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">comments</span>: response.<span class="property">comments</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里的合并是浅合并，所以 <code>this.setState(&#123;comments&#125;)</code> 完整保留了 <code>this.state.posts</code>， 但是完全替换了 <code>this.state.comments</code>。</p>
<h2 id="数据是向下流动的（单向数据流）"><a href="#数据是向下流动的（单向数据流）" class="headerlink" title="数据是向下流动的（单向数据流）"></a>数据是向下流动的（单向数据流）</h2><p>不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。</p>
<p>这就是为什么称 <strong>state 为局部的</strong>或是封装的的原因。除了拥有并设置了它的组件，<strong>其他组件都无法访问</strong>。</p>
<p>组件可以选择把它的 state 作为 props 向下传递到它的子组件中：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">FormattedDate</span> date=&#123;<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">date</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p><code>FormattedDate</code> 组件会在其 props 中接收参数 <code>date</code>，但是<strong>组件本身无法知道它是来自于 <code>Clock</code> 的 state，或是 <code>Clock</code> 的 props，还是手动输入的</strong>。</p>
<p>这通常会被叫做“自上而下”或是<strong>“单向”的数据流</strong>。任何的 <strong>state 总是所属于特定的组件</strong>，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。</p>
<p>如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。</p>
<h4 id="每个组件都是真正独立的。"><a href="#每个组件都是真正独立的。" class="headerlink" title="每个组件都是真正独立的。"></a>每个组件都是真正独立的。</h4>]]></content>
      <categories>
        <category>《React》笔记</category>
        <category>核心概念</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>事件处理</title>
    <url>/2024/03/24/react/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="与传统HTML绑定事件的区别"><a href="#与传统HTML绑定事件的区别" class="headerlink" title="与传统HTML绑定事件的区别"></a>与传统HTML绑定事件的区别</h2><p>传统的 HTML：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;activateLasers()&quot;</span>&gt;</span></span><br><span class="line">  Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 React 中略微不同：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.事件名为小驼峰； 2.传入函数以大括号包裹函数名形式</span></span><br><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;</span><br><span class="line">  <span class="title class_">Activate</span> <span class="title class_">Lasers</span></span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</li>
<li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</li>
</ul>
<h3 id="阻止默认事件-合成事件对象"><a href="#阻止默认事件-合成事件对象" class="headerlink" title="阻止默认事件 (合成事件对象)"></a>阻止默认事件 (合成事件对象)</h3><p>在 React 中，你需要这样阻止默认事件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ActionLink</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The link was clicked.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      Click me</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>e</code> 是一个<strong>合成事件</strong>。React 根据 <a href="https://www.w3.org/TR/DOM-Level-3-Events/">W3C 规范</a>来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。React 事件与原生事件不完全相同。如果想了解更多，请查看 <a href="https://zh-hans.reactjs.org/docs/events.html"><code>SyntheticEvent</code></a> 参考指南。</p>
<h2 id="绑定事件的方式"><a href="#绑定事件的方式" class="headerlink" title="绑定事件的方式"></a>绑定事件的方式</h2><p>使用 React 时，你一般不需要使用 <code>addEventListener</code> 为已创建的 DOM 元素添加监听器。事实上，你只需要在该元素初始渲染的时候添加监听器即可。</p>
<p>当你使用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">ES6 class</a> 语法定义一个组件的时候，通常的做法是将事件处理函数声明为 class 中的方法。例如，下面的 <code>Toggle</code> 组件会渲染一个让用户切换开关状态的按钮：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Toggle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">isToggleOn</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了在回调中使用 `this`，这个绑定是必不可少的</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)；</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">hadleClick</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">isToggleOn</span>: !state.<span class="property">isToggleOn</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      <span class="comment">// 为了能在这里使用 this.handleClick调用方法，因此需要在构造函数内添加handleChick属性指向回调方法 ？</span></span><br><span class="line">    	<span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.state.isToggleOn ? &#x27;ON&#x27; : &#x27;OFF&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">Toggle</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>你必须谨慎对待 JSX 回调函数中的 <code>this</code>，在 JavaScript 中，class 的方法默认不会<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind">绑定</a> <code>this</code>。如果你忘记绑定 <code>this.handleClick</code> 并把它传入了 <code>onClick</code>，当你调用这个函数的时候 <code>this</code> 的值为 <code>undefined</code>。</p>
<p>这并不是 React 特有的行为；这其实与 <a href="https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/">JavaScript 函数工作原理</a>有关。通常情况下，如果你没有在方法后面添加 <code>()</code>，例如 <code>onClick=&#123;this.handleClick&#125;</code>，你应该**为这个方法绑定 <code>this</code>**。</p>
<p>如果觉得使用 <code>bind</code> 很麻烦，这里有两种方式可以解决。如果你正在使用实验性的 <a href="https://babeljs.io/docs/plugins/transform-class-properties/">public class fields 语法</a>，你可以使用 class fields 正确的绑定回调函数：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingButton</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// 此语法确保 `handleClick` 内的 `this` 已被绑定。</span></span><br><span class="line">  <span class="comment">// 注意: 这是 *实验性* 语法。</span></span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is:&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/facebookincubator/create-react-app">Create React App</a> 默认启用此语法。</p>
<p>如果你没有使用 class fields 语法，你可以在回调中使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingButton</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is:&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 此语法确保 `handleClick` 内的 `this` 已被绑定。</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.handleClick()&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此语法问题在于每次渲染 <code>LoggingButton</code> 时都会创建不同的回调函数。在大多数情况下，这没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。<strong>我们通常建议在构造器中绑定或使用 class fields 语法来避免这类性能问题</strong>。</p>
<h3 id="事件命名规范"><a href="#事件命名规范" class="headerlink" title="事件命名规范"></a>事件命名规范</h3><p>在 React 中，有一个命名规范，通常会将代表事件的监听 prop 命名为 <code>on[Event]</code>，将处理事件的监听方法命名为 <code>handle[Event]</code> 这样的格式。</p>
<h2 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h2><p>在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 <code>id</code> 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">deleteRow</span>(id, e)&#125;&gt;<span class="title class_">Delete</span> <span class="title class_">Row</span>&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.deleteRow.bind(this,</span> <span class="attr">id</span>)&#125;&gt;</span>Delete Row<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>上述两种方式是等价的，分别通过<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind"><code>Function.prototype.bind</code></a> 来实现。</p>
<p>在这两种情况下，<strong>React 的事件对象 <code>e</code> 会被作为第二个参数传递</strong>。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>
]]></content>
      <categories>
        <category>《React》笔记</category>
        <category>核心概念</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>元素渲染</title>
    <url>/2021/03/24/react/%E5%85%83%E7%B4%A0%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h1 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h1><p>元素是构成 React 应用的最小砖块，描述了你在屏幕上想看到的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<p>与浏览器的 DOM 元素不同，<strong>React 元素是创建开销极小的普通对象</strong>。React DOM 会负责更新 DOM 来与 React 元素保持一致。</p>
<h2 id="将一个元素渲染为-DOM"><a href="#将一个元素渲染为-DOM" class="headerlink" title="将一个元素渲染为 DOM"></a>将一个元素渲染为 DOM</h2><p>假设你的 HTML 文件某处有一个 <code>&lt;div&gt;</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>根节点，React应用只有单一根DOM节点</p>
<blockquote>
<p> 但一个html页面可以有多个React应用，每个应用对应一个独立根节点。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(el, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br></pre></td></tr></table></figure>



<h2 id="更新已渲染的元素"><a href="#更新已渲染的元素" class="headerlink" title="更新已渲染的元素"></a>更新已渲染的元素</h2><p>React 元素是<a href="https://en.wikipedia.org/wiki/Immutable_object">不可变对象</a>。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。</p>
<p>根据我们已有的知识，更新 UI 唯一的方式是创建一个全新的元素，并将其传入 <a href="https://zh-hans.reactjs.org/docs/react-dom.html#render"><code>ReactDOM.render()</code></a>。</p>
<p>考虑一个计时器的例子：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// element是一个React元素</span></span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;new Date().toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(element, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>注意：在实践中，**大多数 React 应用只会调用一次 <a href="https://zh-hans.reactjs.org/docs/react-dom.html#render"><code>ReactDOM.render()</code></a><strong>。在下一个章节，我们将学习如何将这些代码封装到</strong><a href="https://zh-hans.reactjs.org/docs/state-and-lifecycle.html">有状态组件</a>**中。</p>
<h2 id="React-只更新它需要更新的部分"><a href="#React-只更新它需要更新的部分" class="headerlink" title="React 只更新它需要更新的部分"></a>React 只更新它需要更新的部分</h2><p>上个例子中，尽管每一秒我们都会新建一个描述整个 UI 树的元素，但React DOM <strong>只会更新实际改变了的内</strong>容。</p>
]]></content>
      <categories>
        <category>《React》笔记</category>
        <category>核心概念</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>列表&amp;Key</title>
    <url>/2024/03/24/react/%E5%88%97%E8%A1%A8&amp;Key/</url>
    <content><![CDATA[<h1 id="列表-Key"><a href="#列表-Key" class="headerlink" title="列表 &amp; Key"></a>列表 &amp; Key</h1><p>如下代码，我们使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><code>map()</code></a> 函数让数组中的每一项变双倍，然后我们得到了一个新的列表 <code>doubled</code> 并打印出来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> doubled = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">number</span>) =&gt;</span> number * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doubled);</span><br></pre></td></tr></table></figure>

<p>在 React 中，把数组转化为<a href="https://zh-hans.reactjs.org/docs/rendering-elements.html">元素</a>列表的过程是相似的。</p>
<h2 id="渲染多个组件"><a href="#渲染多个组件" class="headerlink" title="渲染多个组件"></a>渲染多个组件</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 通过map方法将数值放入li，形成一个li标签组成的数值，在一次性放入ul</span></span><br><span class="line"><span class="keyword">const</span> listItems = numbers.<span class="title function_">map</span>(<span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;numbers&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;listItems&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h2 id="基础列表组件"><a href="#基础列表组件" class="headerlink" title="基础列表组件"></a>基础列表组件</h2><p>将列表组合成一个组件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">NumberList</span>(<span class="params">props</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.<span class="property">numbers</span></span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.<span class="title function_">map</span>(<span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 记得给列表元素添加key</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;number.toString()&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    	&#123;number&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  	<span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;listItems&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">NumberList</span> <span class="attr">numbers</span>=<span class="string">&#123;numbers&#125;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p><strong>key 帮助 React 识别哪些元素改变了</strong>，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。</p>
<p>一个元素的 key 最好是这个元素在列表中拥有的<strong>一个独一无二的字符串</strong>。<strong>通常，我们使用数据中的 id 来作为元素的 key</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> todoItems = todos.<span class="title function_">map</span>(<span class="function">(<span class="params">todo</span>) =&gt;</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;todo.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       &#123;todo.text&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>当元素没有确定 id 的时候，<strong>万不得已你可以使用元素索引 index 作为 key</strong>：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> todoItems = todos.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span></span><br><span class="line">  <span class="comment">// 只有item中没有id 才用index代替</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;item.text&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。</strong></p>
<p>如果你选择不指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值</p>
<h2 id="用-key-提取组件-在map方法内设置key"><a href="#用-key-提取组件-在map方法内设置key" class="headerlink" title="用 key 提取组件 (在map方法内设置key)"></a>用 key 提取组件 (在map方法内设置key)</h2><p>元素的 key 只有放在就近的数组上下文中才有意义。</p>
<p><strong>例子：不正确的使用 key 的方式</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ListItem</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = props.<span class="property">value</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 错误！你不需要在这里指定 key：</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;value.toString()&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;value&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">NumberList</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.<span class="property">numbers</span>;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">    <span class="comment">// 错误！元素的 key 应该在这里指定：</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ListItem</span> <span class="attr">value</span>=<span class="string">&#123;number&#125;</span> /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;listItems&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">NumberList</span> <span class="attr">numbers</span>=<span class="string">&#123;numbers&#125;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>一个好的经验法则是：<strong>在 <code>map()</code> 方法中的元素需要设置 key 属性</strong>。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="key-只是在兄弟节点之间必须唯一"><a href="#key-只是在兄弟节点之间必须唯一" class="headerlink" title="key 只是在兄弟节点之间必须唯一"></a>key 只是在兄弟节点之间必须唯一</h2><p>数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们<strong>不需要是全局唯一的</strong>。当我们生成两个不同的数组时，我们可以使用相同的 key 值。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Blog</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> sidebar = (    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.posts.map((post) =&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;post.id&#125;</span>&gt;</span>          &#123;post.title&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> content = props.<span class="property">posts</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">post</span>) =&gt;</span>    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;post.id&#125;</span>&gt;</span>      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;post.title&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;post.content&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;sidebar&#125;      <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;content&#125;    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> posts = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">&#x27;Hello World&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;Welcome to learning React!&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">&#x27;Installation&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;You can install React from npm.&#x27;</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Blog</span> <span class="attr">posts</span>=<span class="string">&#123;posts&#125;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h3 id="不能用key当props名传给子组件"><a href="#不能用key当props名传给子组件" class="headerlink" title="不能用key当props名传给子组件"></a>不能用<code>key</code>当props名传给子组件</h3><p>key 会传递信息给 React ，但不会传递给你的组件。如果你的组件中需要使用 <code>key</code> 属性的值，请用其他属性名显式传递这个值：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> content = posts.<span class="title function_">map</span>(<span class="function">(<span class="params">post</span>) =&gt;</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Post</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">key</span>=<span class="string">&#123;post.id&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">id</span>=<span class="string">&#123;post.id&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">title</span>=<span class="string">&#123;post.title&#125;</span> /&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面例子中，<code>Post</code> 组件可以读出 <code>props.id</code>，但是**不能读出 <code>props.key</code>**。</p>
<h2 id="在-JSX-中嵌入-map"><a href="#在-JSX-中嵌入-map" class="headerlink" title="在 JSX 中嵌入 map()"></a>在 JSX 中嵌入 map()</h2><p>JSX 允许在大括号中<a href="https://zh-hans.reactjs.org/docs/introducing-jsx.html#embedding-expressions-in-jsx">嵌入任何表达式</a>，所以我们可以内联 <code>map()</code> 返回的结果：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">NumberList</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.<span class="property">numbers</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;</span></span><br><span class="line"><span class="language-xml">        numbers.map((number) =&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ListItem</span> <span class="attr">key</span>=<span class="string">&#123;number.toString()&#125;</span> <span class="attr">value</span>=<span class="string">&#123;number&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        )</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么做有时可以使你的代码更清晰，但有时这种风格也会被滥用。</p>
<p>就像在 JavaScript 中一样，何时需要为了可读性提取出一个变量，这完全取决于你。但请记住，如果一个 <code>map()</code> 嵌套了太多层级，那可能就是你<a href="https://zh-hans.reactjs.org/docs/components-and-props.html#extracting-components">提取组件</a>的一个好时机。</p>
]]></content>
      <categories>
        <category>《React》笔记</category>
        <category>核心概念</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>条件渲染</title>
    <url>/2024/03/24/react/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><p>React 中的条件渲染和 JavaScript 中的一样，使用 JavaScript 运算符 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else"><code>if</code></a> 或者<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator">条件运算符</a>去创建元素来表现当前的状态，然后让 React 根据它们来更新 UI。</p>
<p>观察这两个组件:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">UserGreeting</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome back!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">GuestGreeting</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please sign up.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>再创建一个 <code>Greeting</code> 组件，它会根据用户是否登录来决定显示上面的哪一个组件。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = props.<span class="property">isLoggedIn</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据条件来渲染组件(UI)</span></span><br><span class="line">  <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="comment">// Try changing to isLoggedIn=&#123;true&#125;:</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Greeting</span> <span class="attr">isLoggedIn</span>=<span class="string">&#123;false&#125;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h2 id="元素变量"><a href="#元素变量" class="headerlink" title="元素变量"></a>元素变量</h2><p>你可以使用变量来储存元素。 它可以帮助你有条件地渲染组件的一部分，而其他的渲染部分并不会因此而改变。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoginControl</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleLoginClick</span> = <span class="variable language_">this</span>.<span class="property">handleLoginClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleLogoutClick</span> = <span class="variable language_">this</span>.<span class="property">handleLogoutClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">isLoggedIn</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleLoginClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">isLoggedIn</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleLogoutClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">isLoggedIn</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> isLoggedIn = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isLoggedIn</span>;</span><br><span class="line">    <span class="keyword">let</span> button;</span><br><span class="line">    <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">      button = <span class="language-xml"><span class="tag">&lt;<span class="name">LogoutButton</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleLogoutClick&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      button = <span class="language-xml"><span class="tag">&lt;<span class="name">LoginButton</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleLoginClick&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Greeting</span> <span class="attr">isLoggedIn</span>=<span class="string">&#123;isLoggedIn&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;button&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">LoginControl</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><a href="https://codepen.io/gaearon/pen/QKzAgB?editors=0010"><strong>在 CodePen 上尝试</strong></a></p>
<blockquote>
<p>此方式有些复杂~</p>
</blockquote>
<h2 id="与运算符"><a href="#与运算符" class="headerlink" title="与运算符 &amp;&amp;"></a>与运算符 &amp;&amp;</h2><p>通过花括号包裹代码，你可以<a href="https://zh-hans.reactjs.org/docs/introducing-jsx.html#embedding-expressions-in-jsx">在 JSX 中嵌入表达式</a>。这也包括 JavaScript 中的逻辑与 (&amp;&amp;) 运算符。它可以很方便地进行元素的条件渲染：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Mailbox</span>(<span class="params">props</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> unreadMeg = props.<span class="property">unreadMeg</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    	&#123;</span></span><br><span class="line"><span class="language-xml">        unreadMeg.length &amp;&amp;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">h2</span>&gt;</span>You have &#123;unreadMeg.length&#125; unread messages<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> meg = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;33&#x27;</span>]</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">Mailbox</span> <span class="attr">unreadMeg</span>=<span class="string">&#123;meg&#125;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果条件是 <code>true</code>，<code>&amp;&amp;</code> 右侧的元素就会被渲染，如果是 <code>false</code>，React 会忽略并跳过它。</p>
<p>请<strong>注意</strong>，返回 false 的表达式会使 <code>&amp;&amp;</code> 后面的元素被跳过，但会返回 false 表达式。在下面示例中，render 方法的返回值是 <code>&lt;div&gt;0&lt;/div&gt;</code>。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      // 这里会渲染count的值</span></span><br><span class="line"><span class="language-xml">      &#123; count &amp;&amp; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Messages: &#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isLoggedIn</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      The user is <span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123;isLoggedIn ? &#x27;currently&#x27; : &#x27;not&#x27;&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span> logged in.</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isLoggedIn</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;isLoggedIn</span></span><br><span class="line"><span class="language-xml">        ? <span class="tag">&lt;<span class="name">LogoutButton</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleLogoutClick&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        : <span class="tag">&lt;<span class="name">LoginButton</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleLoginClick&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可通过三目运算符来条件渲染相应组件。</p>
</blockquote>
<h2 id="阻止组件渲染"><a href="#阻止组件渲染" class="headerlink" title="阻止组件渲染"></a>阻止组件渲染</h2><p>通过让 <code>render</code> 方法直接返回 <code>null</code>阻止渲染：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">WarningBanner</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!props.<span class="property">warn</span>) &#123;</span><br><span class="line">    <span class="comment">// 返回null则不渲染此组件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;warning&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      Warning!</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Page</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">showWarning</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleToggleClick</span> = <span class="variable language_">this</span>.<span class="property">handleToggleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleToggleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">showWarning</span>: !state.<span class="property">showWarning</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">WarningBanner</span> <span class="attr">warn</span>=<span class="string">&#123;this.state.showWarning&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleToggleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;this.state.showWarning ? &#x27;Hide&#x27; : &#x27;Show&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Page</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在组件的 <code>render</code> 方法中返回 <code>null</code> 并不会影响组件的生命周期。例如，上面这个示例中，<code>componentDidUpdate</code> 依然会被调用。</p>
]]></content>
      <categories>
        <category>《React》笔记</category>
        <category>核心概念</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>状态提升 (共享状态)</title>
    <url>/2024/03/26/react/%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<h1 id="状态提升-共享状态"><a href="#状态提升-共享状态" class="headerlink" title="状态提升 (共享状态)"></a>状态提升 (共享状态)</h1><p>通常，<strong>多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去</strong>。</p>
<p>在 React 中，<strong>将多个组件中需要共享的 state 向上移动到它们的最近共同父组件中，便可实现共享 state。这就是所谓的“状态提升”</strong></p>
<p>两个输入框共享数据的例子：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scaleNames = &#123;</span><br><span class="line">  <span class="attr">c</span>: <span class="string">&#x27;摄氏度&#x27;</span>,</span><br><span class="line">  <span class="attr">f</span>: <span class="string">&#x27;华氏度&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转摄氏度</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toCelsius</span>(<span class="params">fahrenheit</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (fahrenheit - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转华氏度</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toFahrenheit</span>(<span class="params">celsius</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (celsius * <span class="number">9</span> / <span class="number">5</span>) + <span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换，为空时返回空，否则返回保留三位小数的浮点数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tryConvert</span>(<span class="params">temperature, convert</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> input = <span class="built_in">parseFloat</span>(temperature);</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(input)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> output = <span class="title function_">convert</span>(input);</span><br><span class="line">  <span class="comment">// Math.round返回一个数字四舍五入后的整数</span></span><br><span class="line">  <span class="keyword">const</span> rounded = <span class="title class_">Math</span>.<span class="title function_">round</span>(output * <span class="number">1000</span>) / <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> rounded.<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 水是否会沸腾</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">BoilingVerdict</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (props.<span class="property">celsius</span> &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>水会沸腾.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>水不会沸腾.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件 - 输入框</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemperatureInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props); <span class="comment">// 接收父组件传入props</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleChange</span> = <span class="variable language_">this</span>.<span class="property">handleChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>); <span class="comment">// 绑定回调函数，并修正this</span></span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 处理change</span></span><br><span class="line">  <span class="title function_">handleChange</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// e是合成事件对象，通过e.target.value 取值</span></span><br><span class="line">    <span class="comment">// 调用父组件传入的onTemperatureChange函数，并传值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">onTemperatureChange</span>(e.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当子组件输入框值改变时调用父组件的onTemperatureChange方法，并传出值。</span></span><br><span class="line">    <span class="comment">// 另外，onTemperatureChange命名方式：`在&lt;子组件&gt;变更`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 接收父组件传入的温度值</span></span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">temperature</span>;</span><br><span class="line">    <span class="comment">// 接收父组件传入的衡量方式</span></span><br><span class="line">    <span class="keyword">const</span> scale = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">scale</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">legend</span>&gt;</span>输入温度-&#123;scaleNames[scale]&#125;:<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;temperature&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件 - 计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props); <span class="comment">// 接收父组件传入props</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定事件回调，并修正this</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleCelsiusChange</span> = <span class="variable language_">this</span>.<span class="property">handleCelsiusChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleFahrenheitChange</span> = <span class="variable language_">this</span>.<span class="property">handleFahrenheitChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="comment">// 创建初始状态值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">temperature</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">scale</span>: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 处理`摄氏度`变更</span></span><br><span class="line">  <span class="title function_">handleCelsiusChange</span>(<span class="params">temperature</span>) &#123;</span><br><span class="line">    <span class="comment">// temperature接收到子组件传来的参数，并通过setState修改状态</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">scale</span>: <span class="string">&#x27;c&#x27;</span>, temperature&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 处理`华氏度`变更</span></span><br><span class="line">  <span class="title function_">handleFahrenheitChange</span>(<span class="params">temperature</span>) &#123;</span><br><span class="line">    <span class="comment">// temperature接收到子组件传来的参数，并通过setState修改状态</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">scale</span>: <span class="string">&#x27;f&#x27;</span>, temperature&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 渲染函数（每当state改变都会调用）</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 取得当前state下的值</span></span><br><span class="line">    <span class="keyword">const</span> scale = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">scale</span>;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">temperature</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据scale值取得相应的温度数据</span></span><br><span class="line">    <span class="keyword">const</span> celsius = scale === <span class="string">&#x27;f&#x27;</span> ? <span class="title function_">tryConvert</span>(temperature, toCelsius) : temperature;</span><br><span class="line">    <span class="keyword">const</span> fahrenheit = scale === <span class="string">&#x27;c&#x27;</span> ? <span class="title function_">tryConvert</span>(temperature, toFahrenheit) : temperature;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 返回渲染的元素</span></span><br><span class="line">    <span class="comment">// 插入子组件TemperatureInput传入相应的参数，onTemperatureChange指定为当前组件的回调函数</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">TemperatureInput</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">scale</span>=<span class="string">&quot;c&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">temperature</span>=<span class="string">&#123;celsius&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onTemperatureChange</span>=<span class="string">&#123;this.handleCelsiusChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">TemperatureInput</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">scale</span>=<span class="string">&quot;f&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">temperature</span>=<span class="string">&#123;fahrenheit&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onTemperatureChange</span>=<span class="string">&#123;this.handleFahrenheitChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">BoilingVerdict</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">celsius</span>=<span class="string">&#123;parseFloat(celsius)&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染DOM</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Calculator</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><a href="https://codepen.io/gaearon/pen/WZpxpz?editors=0010"><strong>在 CodePen 上尝试</strong></a></p>
<p>::: note</p>
<ol>
<li>父组件给所有子组件传入state的值</li>
<li>子组件修改值时调用父组件的方法并把值传出</li>
<li>父组件接收到值之后修改state</li>
<li>state被修改之后重新执行render函数，并回到第1步<br>:::</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>任何可变数据应当只有一个相对应的唯一“数据源”</p>
<ul>
<li>通常，state 都是首先添加到需要渲染数据的组件中去</li>
<li>然后，如果其他组件也需要这个 state，那么你可以将它提升至这些组件的最近共同父组件中</li>
<li>你应当依靠<a href="https://zh-hans.reactjs.org/docs/state-and-lifecycle.html#the-data-flows-down">自上而下的数据流</a>，而不是尝试在不同组件间同步 state。</li>
</ul>
</li>
<li><p>“存在”于组件中的任何 state，仅有组件自己能够修改它</p>
</li>
<li><p>如果某些数据可以由 props 或 state 推导得出，那么它就不应该存在于 state 中。（如上例中，经过tryConvert方法转换的后的值。）</p>
</li>
</ul>
<h3 id="React开发者工具（debug）"><a href="#React开发者工具（debug）" class="headerlink" title="React开发者工具（debug）"></a>React开发者工具（debug）</h3><p>当你在 UI 中发现错误时，可以使用 <a href="https://github.com/facebook/react/tree/master/packages/react-devtools">React 开发者工具</a> 来检查问题组件的 props，并且按照组件树结构逐级向上搜寻，直到定位到负责更新 state 的那个组件。</p>
]]></content>
      <categories>
        <category>《React》笔记</category>
        <category>核心概念</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>组合vs继承</title>
    <url>/2024/03/26/react/%E7%BB%84%E5%90%88vs%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="组合vs继承"><a href="#组合vs继承" class="headerlink" title="组合vs继承"></a>组合vs继承</h1><p>React 有十分强大的组合模式。我们<strong>推荐使用组合而非继承来实现组件间的代码重用</strong>。</p>
<h2 id="包含关系-组件组合"><a href="#包含关系-组件组合" class="headerlink" title="包含关系 (组件组合)"></a>包含关系 (组件组合)</h2><p>有些组件无法提前知晓它们子组件的具体内容。在 <code>Sidebar</code>（侧边栏）和 <code>Dialog</code>（对话框）等展现通用容器（box）的组件中特别容易遇到这种情况。</p>
<h3 id="props的children属性（类似vue的插槽）"><a href="#props的children属性（类似vue的插槽）" class="headerlink" title="props的children属性（类似vue的插槽）"></a>props的children属性（类似vue的插槽）</h3><p>我们建议这些组件使用一个<strong>特殊的 <code>children</code> prop 来将他们的子组件传递到渲染结果中</strong>：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FancyBorder</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">FancyBorder</span> <span class="attr">FancyBorder-</span>&#x27; + <span class="attr">props.color</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      // children 是特殊的prop，在父组件中没有显式声明</span></span><br><span class="line"><span class="language-xml">      &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">WelcomeDialog</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">FancyBorder</span> <span class="attr">color</span>=<span class="string">&quot;blue&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      // 子组件标签之间的内容被当做 props.children 传入</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-title&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Welcome</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-message&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Thank you for visiting our spacecraft!</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">FancyBorder</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>:::note</p>
<p>类似于vue中的插槽</p>
<p>:::</p>
<h3 id="props传入组件（类似vue命名插槽）"><a href="#props传入组件（类似vue命名插槽）" class="headerlink" title="props传入组件（类似vue命名插槽）"></a>props传入组件（类似vue命名插槽）</h3><p>少数情况下，你可能需要在一个组件中预留出几个“洞”。这种情况下，我们可以不使用 <code>children</code>，而是自行约定：将所需内容传入 props，并使用相应的 prop。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SplitPane</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;SplitPane&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;SplitPane-left&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;props.left&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;SplitPane-right&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;props.right&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// props传入组件</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">SplitPane</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">left</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &lt;<span class="attr">Contacts</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">      right=&#123;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Chat</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#125; /&gt;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;Contacts /&gt;</code> 和 <code>&lt;Chat /&gt;</code> 之类的 React 元素本质就是对象（object），所以你可以把它们当作 props，像其他数据一样传递。<strong>你可以将任何格式的数据作为 props 进行传递。</strong></p>
<p>:::note</p>
<p>类似于vue中的命名插槽</p>
<p>:::</p>
<h2 id="特例关系（字符串与组件组合）"><a href="#特例关系（字符串与组件组合）" class="headerlink" title="特例关系（字符串与组件组合）"></a>特例关系（字符串与组件组合）</h2><p>有些时候，我们会把一些组件看作是其他组件的特殊实例，比如 <code>WelcomeDialog</code> 可以说是 <code>Dialog</code> 的特殊实例。</p>
<p>在 React 中，我们也可以通过组合来实现这一点。“特殊”组件可以通过 props 定制并渲染“一般”组件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dialog</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">FancyBorder</span> <span class="attr">color</span>=<span class="string">&quot;blue&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-title&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        // 这里props.title非组件对象，而是字符串</span></span><br><span class="line"><span class="language-xml">        &#123;props.title&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-message&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;props.message&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">FancyBorder</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">WelcomeDialog</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Dialog</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">title</span>=<span class="string">&quot;Welcome&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">message</span>=<span class="string">&quot;Thank you for visiting our spacecraft!&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="class方式的组件组合"><a href="#class方式的组件组合" class="headerlink" title="class方式的组件组合"></a>class方式的组件组合</h2><p>组合也同样适用于以 class 形式定义的组件。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dialog</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">FancyBorder</span> <span class="attr">color</span>=<span class="string">&quot;blue&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-title&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;props.title&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-message&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;props.message&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">FancyBorder</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SignUpDialog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleChange</span> = <span class="variable language_">this</span>.<span class="property">handleChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleSignUp</span> = <span class="variable language_">this</span>.<span class="property">handleSignUp</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">login</span>: <span class="string">&#x27;&#x27;</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Dialog</span> <span class="attr">title</span>=<span class="string">&quot;Mars Exploration Program&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">message</span>=<span class="string">&quot;How should we refer to you?&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;this.state.login&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleSignUp&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          Sign Me Up!</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Dialog</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleChange</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">login</span>: e.<span class="property">target</span>.<span class="property">value</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleSignUp</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`Welcome aboard, <span class="subst">$&#123;<span class="variable language_">this</span>.state.login&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="那么继承呢？（不推荐）"><a href="#那么继承呢？（不推荐）" class="headerlink" title="那么继承呢？（不推荐）"></a>那么继承呢？（不推荐）</h2><p>在 Facebook，我们在成百上千个组件中使用 React。我们并没有发现需要使用继承来构建组件层次的情况。</p>
<p>Props 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。<strong>注意：组件可以接受任意 props，包括基本数据类型，React 元素以及函数</strong>。</p>
<p>如果你想要在组件间复用非 UI 的功能，我们建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入（import）而<strong>无需通过 extend 继承它们</strong>。</p>
]]></content>
      <categories>
        <category>《React》笔记</category>
        <category>核心概念</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>表单</title>
    <url>/2024/03/24/react/%E8%A1%A8%E5%8D%95/</url>
    <content><![CDATA[<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><h2 id="受控组件（双向数据绑定）"><a href="#受控组件（双向数据绑定）" class="headerlink" title="受控组件（双向数据绑定）"></a>受控组件（双向数据绑定）</h2><p>在 HTML 中，表单元素（如<code>&lt;input&gt;</code>、 <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code>）通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 <a href="https://zh-hans.reactjs.org/docs/react-component.html#setstate"><code>setState()</code></a>来更新。</p>
<p>我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。</p>
<p>例如，如果我们想让前一个示例在提交时打印出名称，我们可以将表单写为受控组件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleChange</span> = <span class="variable language_">this</span>.<span class="property">handleChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleSubmit</span> = <span class="variable language_">this</span>.<span class="property">handleSubmit</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleChange</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">value</span>: event.<span class="property">target</span>.<span class="property">value</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleSubmit</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">value</span>)</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          名字:</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类似于vue中的双向绑定，v-model</p>
</blockquote>
<h2 id="textarea-标签（使用value定义值）"><a href="#textarea-标签（使用value定义值）" class="headerlink" title="textarea 标签（使用value定义值）"></a>textarea 标签（使用value定义值）</h2><p>在 HTML 中, <code>&lt;textarea&gt;</code> 元素通过其子元素定义其文本:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span></span><br><span class="line">  你好， 这是在 text area 里的文本</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>在 React 中，<code>&lt;textarea&gt;</code> 使用 <code>value</code> 属性赋值</strong>。这样，可以使得使用 <code>&lt;textarea&gt;</code> 的表单和使用单行 input 的表单非常类似：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EssayForm</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="string">&#x27;请撰写一篇关于你喜欢的 DOM 元素的文章.&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleChange</span> = <span class="variable language_">this</span>.<span class="property">handleChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleSubmit</span> = <span class="variable language_">this</span>.<span class="property">handleSubmit</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">value</span>: event.<span class="property">target</span>.<span class="property">value</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleSubmit</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;提交的文章: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">value</span>);</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          文章:</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span>        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，<code>this.state.value</code> 初始化于构造函数中，因此文本区域默认有初值</strong></p>
<h2 id="select-标签-（value代替选中属性）"><a href="#select-标签-（value代替选中属性）" class="headerlink" title="select 标签 （value代替选中属性）"></a>select 标签 （value代替选中属性）</h2><p><strong>React 在根 <code>select</code> 标签上使用 <code>value</code> 属性代替<code>option</code>元素上的<code>selected</code> 属性（选中属性）</strong></p>
<p>在 HTML 中，<code>&lt;select&gt;</code> 创建下拉列表标签。例如，如下 HTML 创建了水果相关的下拉列表：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;select&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;grapefruit&quot;</span>&gt;</span>葡萄柚<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;lime&quot;</span>&gt;</span>酸橙<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span> <span class="attr">value</span>=<span class="string">&quot;coconut&quot;</span>&gt;</span>椰子<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;mango&quot;</span>&gt;</span>芒果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>请注意，由于 <code>selected</code> 属性的缘故，椰子选项默认被选中。<strong>React 并不会使用 <code>selected</code> 属性，而是在根 <code>select</code> 标签上使用 <code>value</code> 属性</strong>。这在受控组件中更便捷，因为您只需要在根标签中更新它。例如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FlavorForm</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">value</span>: <span class="string">&#x27;coconut&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleChange</span> = <span class="variable language_">this</span>.<span class="property">handleChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleSubmit</span> = <span class="variable language_">this</span>.<span class="property">handleSubmit</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">value</span>: event.<span class="property">target</span>.<span class="property">value</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleSubmit</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;你喜欢的风味是: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">value</span>);</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          选择你喜欢的风味:</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">select</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;grapefruit&quot;</span>&gt;</span>葡萄柚<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;lime&quot;</span>&gt;</span>酸橙<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;coconut&quot;</span>&gt;</span>椰子<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;mango&quot;</span>&gt;</span>芒果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="select多选"><a href="#select多选" class="headerlink" title="select多选"></a>select多选</h3><p>你可以将数组传递到 <code>value</code> 属性中，以支持在 <code>select</code> 标签中选择多个选项：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;select multiple=&#123;<span class="literal">true</span>&#125; value=&#123;[<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]&#125;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>总的来说，这使得 <code>&lt;input type=&quot;text&quot;&gt;</code>, <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 之类的标签都非常相似—它们都接受一个 <code>value</code> 属性，你可以使用它来实现受控组件。</p>
<h2 id="文件-input-标签-（非受控组件）"><a href="#文件-input-标签-（非受控组件）" class="headerlink" title="文件 input 标签 （非受控组件）"></a>文件 input 标签 （非受控组件）</h2><p>在 HTML 中，<code>&lt;input type=&quot;file&quot;&gt;</code> 允许用户从存储设备中选择一个或多个文件，将其上传到服务器，或通过使用 JavaScript 的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/File/Using_files_from_web_applications">File API</a> 进行控制。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为它的 value 只读，所以它是 React 中的一个<strong>非受控</strong>组件。将与其他非受控组件<a href="https://zh-hans.reactjs.org/docs/uncontrolled-components.html#the-file-input-tag">在后续文档中</a>一起讨论。</p>
<h2 id="处理多个输入"><a href="#处理多个输入" class="headerlink" title="处理多个输入"></a>处理多个输入</h2><p>当需要处理多个 <code>input</code> 元素时，我们可以给每个元素添加 <code>name</code> 属性，并让处理函数根据 <code>event.target.name</code> 的值选择要执行的操作。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Reservation</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">isGoing</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">numberOfGuests</span>: <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleInputChange</span> = <span class="variable language_">this</span>.<span class="property">handleInputChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleInputChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = event.<span class="property">target</span>;</span><br><span class="line">    <span class="keyword">const</span> value = target.<span class="property">type</span> === <span class="string">&#x27;checkbox&#x27;</span> ? target.<span class="property">checked</span> : target.<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">const</span> name = target.<span class="property">name</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="comment">// ES6 计算属性名称</span></span><br><span class="line">      [name]: value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          参与:</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">name</span>=<span class="string">&quot;isGoing&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">checked</span>=<span class="string">&#123;this.state.isGoing&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onChange</span>=<span class="string">&#123;this.handleInputChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          来宾人数:</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">name</span>=<span class="string">&quot;numberOfGuests&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">type</span>=<span class="string">&quot;number&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">value</span>=<span class="string">&#123;this.state.numberOfGuests&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onChange</span>=<span class="string">&#123;this.handleInputChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="受控输入空值"><a href="#受控输入空值" class="headerlink" title="受控输入空值"></a>受控输入空值</h2><p>在<a href="https://zh-hans.reactjs.org/docs/forms.html#controlled-components">受控组件</a>上指定 value 的 prop 会阻止用户更改输入。如果你指定了 <code>value</code>，但输入仍可编辑，则可能是你意外地将<code>value</code> 设置为 <code>undefined</code> 或 <code>null</code>。</p>
<p>下面的代码演示了这一点。（输入最初被锁定，但在短时间延迟后变为可编辑。）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;hi&quot;</span> /&gt;</span></span>, mountNode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;null&#125;</span> /&gt;</span></span>, mountNode);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>



<h2 id="受控组件的替代品-非受控组件"><a href="#受控组件的替代品-非受控组件" class="headerlink" title="受控组件的替代品 (非受控组件)"></a>受控组件的替代品 (非受控组件)</h2><p>有时使用受控组件会很麻烦，因为<strong>你需要为数据变化的每种方式都编写事件处理函数，并通过一个 React 组件传递所有的输入 state</strong>。当你将之前的代码库转换为 React 或将 React 应用程序与非 React 库集成时，这可能会令人厌烦。在这些情况下，你可能希望使用<a href="https://zh-hans.reactjs.org/docs/uncontrolled-components.html">非受控组件</a>, 这是实现输入表单的另一种方式。</p>
<h2 id="成熟的解决方案"><a href="#成熟的解决方案" class="headerlink" title="成熟的解决方案"></a>成熟的解决方案</h2><p>如果你想寻找包含验证、追踪访问字段以及处理表单提交的完整解决方案，使用 <a href="https://jaredpalmer.com/formik">Formik</a> 是不错的选择。然而，它也是建立在受控组件和管理 state 的基础之上 —— 所以不要忽视学习它们。</p>
]]></content>
      <categories>
        <category>《React》笔记</category>
        <category>核心概念</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
</search>
